\subsubsection{Buffer Design and Optimize}
The core challenge of design a MapReduce library 
is the organization of MapReduce
intermediate data.
The organization of the Map output is critical to the
performance of many MapReduce applications, 
since the entier body of intermediate data must be
reorganized between the Map and Reduce phase:
Map produces data in the same order as the input,
while Reduce must consume data grouped by key.\cite{mao2010metis}
In a data center this operation is dominated by
the performance of the network, but when running 
on single multicore processor the performance
is dominated by the operations on the data structure
that holds intermediate data.

% DMR默认的buffer是一个hash buffer, map 产生 key-value,根据hash(key) 确定key-value插入的位置。采用hash buffer的优势在于，key的查找长度比较短，为O(1).但是hash buffer 在出发重新映射之前首先需将分散的 key-value 汇集到一块连续的空间中,通常是数组,我们称这个过程为 group 阶段。通过实验的数据发现,group 的开销相当大。此外,hash buffer 的方式,需要大量的动态内存分配。

Defaultly, buffer is a hash table in DMR.
and each element is a array of pointers to key arrays,
where the fixed is by a default value(256);
During the map phase, each map worker uses patition function
to index the buffer.
%When an intermediate key-value pair is generated
%by a map function, 
%The hash function is applied to each key-value. 
Once the buffer is determined, 
the element is indexed by the hash value of the key.
Inside each entry of a hash table,
DMR stores the key-value pairs in an array sorted by key.

If the hash table have enough entries, 
collisions will be rare and the key arrays will be short,
so that lookup and insert will have cost O(1).
The hash table's O(1) lookups make it
particularly attractive for workloads with many repeated keys.
{\color{gray}(the reduce operator is immediately applied
to that pair based on the local container. This process is
performed using a combiner.)}
Hoverver, our producer-consumer model requires
buffer is a contiguous block of memory, 
which implies that key-value of hash table should be gathered
before sending to reduce worker.
We address this issue by copying values out of the hash tables
at the end of the map phase and inserting them into a new contiguous array.
Hence, DMR adds a new internel phase, namely Group,
to group all key-values together.
When the size of buffer exceeds a threshold,
the Group phase will tranverse all key-value to gather them together,
then send the buffer to reduce worker.
This extra copy is unfortunate and time-consuming.
Furthemore, it also requires frequent allocations
and deallocations of memory 
along with the data structure creation and destrcution.

%为了提高效率，避免group阶段产生的开销，我们试图改进buffer的hash实现，它不再采用原来 Phoenix 中的 hash 表的组织方式,而是采用更简单的 array,map worker 产生的 key-value只需追加到 array 中即可,无需排序。

%The buffers are initially sized to a default value and then resized dynamically as needed.
The buffers are initially sized to a default value 
and then reuse the buffer among sub-jobs.
It will indicate that the buffer is empty at the end of a sub-job, 
but will not free the memory until all sub-jobs have finished.
Each map thread could store its output by appending
each key/value pair to array buffer, 
and then as each sub-job is processed in turn,
the data structures and memory spaces 
for the input and intermediate data can be reused across the sub-job boundaries. 
This avoids the costs of expensive memory allocation and deallocation, 
as well as the data structures construction。
This could save the expensive operations such as
concurrent memory allocations and deallocations,
as well as the building of data structures.
For applications that likely have abundant duplicated keys (or values), 
it would be more worthwhile to use array buffer.

%不同于hash buffer, array buffer已经是一块连续的空间，因此无需group阶段，从而可以有小节约时间
Unlike hash buffer, as array buffer is a contiguous block of memory, 
DMR no need Group phase.
Furthemore, the memory access pattern of MapReduce
has poor temporal and spatial locality.%较差的时间和空间的开销
For spatial locality, 
though the input data is sequentially accessed in the Map phase,
a large number of key-compare operations results in poor spatial locality. 
%Futhermore, 由于 L1 cache 的大小有限,group 阶段在遍历时,会更大的可能性访问不在 L1 cache 中的key-value; 而 array buffer 不需要 group 阶段,因此会更少的 cache miss. 如图7左图所示。从而array buffer 可有效提高性能


For the array buffer implementation and no combiner in map phase,
Map just need to . Thus, this technique is more effective
for array buffer implementation than hash table buffer
implementation.

{\color{gray}(A related problem is that eager pipelining moves some of the
sorting work from the mapper to the reducer.
Recall that in the
blocking architecture, map tasks generate sorted output: all the re-
duce task must do is merge together the pre-sorted map output for
each partition. In the eager pipelining design, map tasks send out-
put records in the order in which they are generated, so the reducer
must perform a full external sort. Because the number of map tasks
typically far exceeds the number of reduces [4], moving more work
to the reducer can degrade performance.
)}




%applications of different buffer as table\ref{diff-buf}
%\begin{table}[]
%\centering
%\caption{My caption}
%\label{diff-buf}
%\begin{tabular}{|l|l|}
%\hline
%\multicolumn{2}{|l|}{\textbf{best buffer of applications}} \\ \hline
%\textbf{application}           & \textbf{buffer}           \\ \hline
%histogram                      & array                     \\ \hline
%word count                     & array                     \\ \hline
%linear regression              & hash                      \\ \hline
%string match                   & hash                      \\ \hline
%pca                            & hash                      \\ \hline
%\end{tabular}
%\end{table}
