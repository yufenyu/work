\section{Introduction}
\label{sec:intro}

%%需要调研的部分：解答的问题，为什么我们关注多核的scalability问题。随着分布式系统的广泛普及，企业和用户的通用的做法是通过堆积更多的机器来获取更快的处理效率和速度。但是机器堆积的越多，网络带宽，耗电也越来越多，如何充分利用单台机器的多核资源成为很重要的课题。

%一方面，随着多核机器的广泛普及，如何充分利用多核资源成为非常重要的课题，另一方面，现有的很多我们希望充分利用单台机器上的资源，

%目前的现状，需求
As the prevalence of multicore chips,
it is foreseeable
that tens to hundreds (even thousands) of cores on a single chip
will appear in the near future\cite{Borkar2007core}.
While utilizing multicore sources is still challenging
because of the difficulties of parallel programming.
%另一方面，现在流行的分布式环境
Parallel programming is becoming more and more popular
because of its potential to improve performance, especially in
multicore architectures. In the past, computer software has
been written using serial computation concepts which is
usually less efficient than multithreaded parallel computation.

%引起mapreduce编程模型和Phoenix
MapReduce\cite{dean2004mapreduce} 
is a promising programming model for clusters
to perform large-scale data processing
in a simple and effecient way.
In most cases, programmers only need to implement two interfaces:
Map, which processes the input data and converts it into a 
number of key-value pairs; 
and Reduce, which aggregates values in the
key-value pairs according to the key.
And the programmer dose no need to control synchronization 
and schedule tasks manually.
While initially MapReduce is implemented on clusters, Ranger
et al. have demonstrated the feasibility of running MapReduce
applications on shared memory multicore machines with 
Phoenix\cite{ranger2007phoenix}.
Other libraries such as Metis\cite{mao2010metis} 
and Tiled-mapreduce\cite{chen2010tiled},
also show that MapReduce is a promising programming model 
for multicore platforms to take full advantage of  
processing resources.
Phoenix uses the pthread library to assign tasks 
among CPU cores and relies on
shared memory to handle inter-task communications.

%Phoenix存在的问题，scalability较差的原因
Ideally, adding more processes and cores to the library
would bring about a linear decrease in execution time.
However, the benefits of adding more
cores will be reduced due to overhead associated with the
additional processes--the contention of lock.
A common parallel programming model is shared-memory multithreading, 
where all threads of an application share a single address space. 
This shared address space has a
cost, can limit the scalability of these applications. 
All of these operations are synchronized by a single per-process lock. 
As a result, the performance will be better 
when the number of cores increases from 1 to 4, 
while the performance will be worse if using more than 4 cores.  
Hence, with the continuously increasing
number of cores, it can easily cause resource pressures on the
runtime, operating systems and the CPU caches, which could sig-
nificantly degrade the performance. 

%Compared to the cluster version, MapReduce on multicore is able to take ad-
%vantage of fast inter-task communications in shared memory, thus
%avoids the expensive network communications among tasks.

%我们如何解决这个问题

To remedy the above problems, 
firstly, we propose a Scalable thread libray(\myth).
Then this paper presents a modified model of \myds(Scalable MapReduce), 
that can efficently support MapReduce applications.
\myds reserves the similar Phoenix programing interfaces as well.
Specifically, this paper make the following contributions:(\redt{need talk more....})
\begin{itemize}
  \item We research the reason for bad scalability of Phoenix.
  \item We aim at providing an race-free programming abstraction to
support scalable MapReduce.
  \item We present a scalable MapReduce.
\end{itemize}

%介绍文章的组织结构
In order to ground our discussion, we present an overview
of MapReduce architecture and Phoenix in Section 2. 
We then develop the design of \myth in Section 3, 
keeping the focus on the implementation mechanism of extention. 
%In Section 4 we show how \myth can support
%\myds and illustrate
%the potential benefits of that producer-consumer model for MapReduce framework.
In Section 4 we describe our support for pipelineing map and reduce,
and illustrate the potential benefits of that producer-consumer model for MapReduce framework. 
We present initial performance results in Section 5. 
Related and future work are covered in Sections 6 and 7.

%This paper is organized as follows. In section 2, we review
%the background. Section 3 briefly describes the problems.
%Section 4 presents the experimental setup. Section 5 discusses
%the results in terms of execution time and total power
%consumption. Finally, Section 6 concludes the paper.

