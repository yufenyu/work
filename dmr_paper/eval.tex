\section{Evaluation}


\subsection{diff buffer}


\subsection{Scalability}
{\color{red}phoenix }
\\
We say a waiting thread is the thread which is waiting for shared
data that produced by another thread. If using semaphore for
synchronization, a waiting thread will be blocked and enlisted
on the waiting queue by the OS scheduler. If using spinlock
for synchronization, a waiting thread will do busy wait, i.e.
spinning in a while loop. Embedded software applications
that using semaphore to handle the synchronization could
result in performa+nce overkill, since it involves system calls
translated into thousands of CPU instructions [1]; while using
spinlock have problem of long busy-waiting time.

When a running thread tries to read shared data,
it must do busy wait until it has exhausted its time-slice
or until another thread has withdrawn the occupation on the
shared data. 


Figure \ref{fig:perf:spinlock} shows spin\_lock overhead
as core increasing.
\begin{figure}[!h!t]  
    \centering
    \includegraphics[width=0.45\textwidth]{eps/perf_spinlock.eps}
    \caption{spin lock overhead as core increasing}
    \label{fig:perf:spinlock}
\end{figure}



System performance is evaluated using
instructions per cycle (IPC). Higher IPC means
better performance.
Figure \ref{fig:perf:ipc} shows the IPC of Phoenix first increases 
and then decreases as more threads are run on multi-core system.


{\color{red}\myds }

\subsection{overall performance}

%分析lr性能差的原因

The performance of hist, wc, sm are scale linearly with the number of cores.
\subsection{Fault Tolerance}
