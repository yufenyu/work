\subsection{自我介绍}
我叫俞玉芬，是中国科学技术大学2年级硕士研究生，我的专业是计算机科学与技术，我的课题是面向多核可伸缩的MapReduce的研究。
性格外向，生活态度比较积极，喜欢跑步，骑行，以及户外徒步旅行，还喜欢看一些闲书。工作上，态度认真努力。

\subsection{项目介绍}
我的课题名是“面向多核可扩展性的MapReduce的研究”，我先介绍一下项目的背景。

随着多核机器的广泛普及,如何简单有效地利用多核资源已成为一个十分重要的课题。现有的多核上的并行编程模式,包括共享内存多线程pthread和消息传递MPI,它们需要程序员自己管理线程之间的通信、任务分派和调度，这无形中给程序员增加了很多负担，也让并行编程变的复杂。04年Google提出了MapReduce编程模型，极大的简化了并行编程。受到Google的MapReduce编程思想的启发，耶鲁大学的Range等人将MapReduce编程模型移植到多核环境，他们编写了一套针对多核的MapReduce库，并通过实验证明，应用程序使用MapReduce编程模型在性能上可以与phtread编写的程序相媲美，而且它延续了MapReduce的优点，就是它接口简单，使用方便！

多核环境下的MapReduce库phoenix提出之后，学术界有对phoenix提出了很多的改进和优化。我们通过实验发现，phoenix的可扩展性比较差，具体表现为：应用程序使用phoenix库时，在1-8核环境下，运行时间随着核数的增多而下降；但是8核以上，运行时间不降低，反而上升。特别是在32核环境下，应用程序的运行时间甚至比1核情况的时间都长，非常夸张，也意味着，8核以上的系统，很难在通过phoenix达到理想的性能效果。为了改进这个问题，我的工作是改进phoenix的不可扩展性，重新编写了一套MapReduce模型

涉及的关键技术：MapReduce，线程池的管理，buffer的管理和设计，多线程的编程，进程间的通信，多线程的并发控制问题，

\subsection{MapReduce}
MapReduce是一个编程模型，主要用于处理大的数据集，使用这个模型进行处理时，用户只需要提供两个函数:map和reduce，map函数处理输入的数据，产生中间的key/value键值对；reduce函数将具有相同key的中间结果归并，并产生最终结果。

使用MapReduce编程模型的一个最大优势在于，程序员不需要考虑底层的细节，由运行时系统管理并行，任务的分割，如何在集群环境中进行调度，容错，管理机器间的通信等等。程序员可以不用熟悉并行化，不了解分布式系统的情况下，能够最大化的利用分布式环境的资源。当处理的数据相当大的时候，考虑如何将输入的数据进行分割然后并行的处理，如何充分利用集群环境，如何容错成为关键的问题

{\color{red}结合word\_count来说明MapReduce的处理应用程序的流程，大体流程（map和reduce），其中的细节（split, combiner, merge）}


\subsection{DMR是如何改进和优化phoenix}
1.phoenix的流程，phoenix的局限和不足，phoenix中影响性能的关键因素

2.新的MapReduce库中的做法，优势


phoenix的处理流程的大致流程也是split, map, reduce，有一个master进程，以及一组worker线程组成的线程池（线程池如何实现，如何管理？）。Phoenix中影响性能的关键因素有两点：1.中间结构是一个全局二维数组，多个map线程和reduce线程都可以访问，为了避免负责的读写控制与同步，以及锁的开销，phoenix使用barrier来简化（具体说一下barrier是如何让编程简单），但barrier严重影响性能。2.Phoenix是使用Pthread编写的多线程，多个线程共享主线程的地址空间，除了栈是私有的。这会带来一个问题，当多个线程在读写一个共享变量时，需要锁进行同步。当线程越多时，花费在锁上的开销会越大。

新的MapReduce库针对上述的两个问题进行优化和改进：1.原有的共享中间结构，变为每个线程私有的buffer，map将产生的数据存入到自己私有的buffer中，当buffer满的时候，map就将数据发送给reduce，然后继续做map任务，reduce收到数据后，也可以开始reduce的工作。这样做最大的好处是，map和reduce线程间不需要barrier，增加了并行的程度。buffer的实现

2.Phoenxi中采用多线程进行编程，多个线程共享master主线程的很多资源，这会造成很多锁的开销，特别是核数越多，线程数越多的情况下，越明显。这是造成不可伸缩性的很重要的因素，为此，在新的MapReduce库中，我们的做法是使用进程。（优势和劣势分别是什么？）进程中的fork是采用COW（解释一下什么是COW机制）的机制创建子进程的，各个进程都拥有自己独立的地址空间，创建时子进程共享父进程的地址空间，但是是只读共享，当它试图修改的时候，就会产生一份自己的拷贝。这样可以避免锁的开销。



\subsection{DMR在实现过程中的一些难点问题}



\subsection{DMR的一些缺点和优化点}
虽然DMR的进程地址空间的隔离会让开销变大，但它带来的收益远大于其开销

使用进程模拟线程，本身的开销会比较大，

1.迭代式应用的支持kmeans，线程池。

2.会存在大量key/val的分配，动态内存分配，内存池来实现。

\section{介绍的思路}
简单明了的讲述背景，我的主要工作是优化，重点在于如何去优化phoenix，接下来的一些计划

1.背景: MapReduce, 面向多核的MapReduce库phoenix，我们改进后的MapReduce库

2.phoenix存在的问题：scalability不好，
a.不好的表现是怎样的？
b.目前影响phoenix性能不好的因素
c.scalability不好的原因分析：为了充分利用多核资源phoenix中使用多线程，以充分利用多核资源，进行高度的并发。但多线程存在的问题是什么？


3.从哪几个角度进行改进的：
a.中间数据结构，私有buffer的设计，并尝试不同的buffer的内部实现，破原来的barrier; 
b.针对多线程可扩放性的问题，我们尝试使用进程来完成，但多个进程存在的问题是进程间的通信，编写了一套自己的通道（基于共享内存），底层模型的不一样，我们底层的模型是使用进程来做，不再使用线程（进程和线程的分别优势在于什么）
c.最后的性能表现较好

4.正在考虑和研究的一些问题
a.目前考虑都是从较上层的角度去考虑的，其实内核共享数据结构的竞争，多个cores访问竞争，cache miss的问题，是多核scalability不好的很关键的因素。
b.容错问题

三个大的方面：
1.线程和进程的优缺点的详细对比
2.为了改进性能我们做的buffer的改进
3.



