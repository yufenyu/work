\section{背景}
五个方面：\\
1.确定性并行以及并行编程模型\\
2.分布式环境下的MapReduce，即Google原始的MapReduce，Hadoop，分布式系统\\
3.phoenix，多核环境下的编程模型\\
4.DMR的设计和实现方案\\
5.MapReduce编程模型的不足，衍生为Pregel，spark系统，针对迭代式应用，DMR接下来的改进方式\\

几个问题：\\
1.多核下的MapReduce模型与集群环境下的MapReduce模型的异同对比\\
2.phoenix和DMR的不同支持，DMR的优势和改进在何处\\

\subsection{确定性并行方向}
1.简要介绍课题组目前大的研究方向, 重点介绍我的研究以及我的工作“面向多核可扩展的MapReduce的研究”

2.多核环境下的编程模型, 如何充分利用多核资源，从编程的角度去考虑





\subsection{MapReduce}
多核环境下的MapReduce与集群环境下的MapReduce对比。

不同之处：
1.不同的runtime
虽然两者遵从一致的思想，但毕竟它们面对的环境是完全不一样的，因此：
(a)在多核环境下，master主线程管理一个子线程组成的线程池，每个线程在运行的时候，与cpu上的一个core进行绑定，然后执行任务。
在集群环境下，master也会fork很多子线程，但每个slaver都是一个单独的机器上运行。

(b)在多核环境下，map的产生的中间键值对会被直接存放到内存的共享区，接下来reduce从中取，进行reduce操作，最终的结果存入到内存。
在集群环境下，map产生的中间结果会存放到本地磁盘中，然后通知master，当master安排reduce任务时，reduce会根据master发来的信息，从对应的map的disk中取数据。reduce最终的结果会存入到分布式文件系统GFS.

(c)

2.影响性能的主要因素不同。

多核环境下的MapReduce：性能的主要限制在于中间数据结构的存储，即用于存储key/val的数据结构。因为多个map线程和多个reduce线程有可能同时访问该共享结果，这会涉及并发控制的问题，通常表现为在锁的等待上的开销比较大。已phoenix中的中间数据为例来说明。

集群环境下的MapReduce：最关注的是网络带宽资源，因为worker和master之间的通信是通过网络，降低网络带宽是集群环境下MapReduce考虑的主要问题

为此MapReduce做出的努力有如下几方面：
\begin{itemize}
  \item Map input is read from local disks, not over network，尽量在存放input replication上启动map worker，这样便可以直接从local disk读取，而不是通过网络(moving computation to data)
  \item Map阶段的中间结果存放于local disk而不是GFS中，为什么？
  \item Intermediate data partitioned into files holding many keys，Big network transfers are more efficient
  \item map阶段的combiner操作，所谓combiner就是局部的reduce操作，将一个key对应的多个value进行局部的归并，这样可以有小减少网路通信量，以及本地磁盘空间的使用，以word\_count为例。
\end{itemize}

相同之处：
1.基本的思想和处理流程是一样的
MapReduce是一个编程模型，主要用于处理大的数据集，使用这个模型进行处理时，用户只需要提供两个函数:map和reduce，map函数处理输入的数据，产生中间的key/value键值对；reduce函数将具有相同key的中间结果归并，并产生最终结果。
map和reduce阶段中间有个一个barry，或者成为shuff，即只有所有的map worker都结束后，才能够开始reduce阶段。

2.负载均衡的问题

3.优势相同：简单的编程模型
MapReduce编程模型隐藏了运行时的各种细节，程序员在使用该编程模型的时候，无需考虑并行，负责均衡，资源是否充分被利用，容错等问题，这些都由MapReduce库来管理。用户只需要提供map和reduce两个函数逻辑即可。

关键之处：
优势：
局限性：
