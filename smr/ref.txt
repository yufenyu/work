mgordon-phd-thesis.pdf
======================
5.5.1
Cores communicate using buffered, blocking sends and
receives.
Since sends block when a channel is full and receives block 
when a channel is empty, the compiler needs only to determine
the ordering of the sends and receives rather than arranging 
for a precise rendezvous between sender and receiver.

7.4 Coarse-Grained Software Pipelining

DSM
===
1996. VM-Based Shared Memory on Low-Latency, Remote-Memory-Access
Networks, TR#643, U. of Rochester
Leonidas Kontothanassis2, Galen Hunt, Robert Stets, Nikolaos Hardavellas,
Michał Cierniak, Srinivasan Parthasarathy, Wagner Meira, Jr.,
Sandhya Dwarkadas, and Michael Scott
该文比较两个DSM系统Cashmere和TreadMarks, 二者均use virtual memory to
maintain coherence on pages, and both use lazy, multiwriter
release consistency.The systems differ dramatically,
however, in the mechanisms used to track sharing
information and to collect and merge concurrent updates
to a page, with the result that Cashmere communicates
much more frequently, and at a much finer grain.
****

Implementing Sequentially Consistent Shared Objects using Broadcast and
Point-To-Point Communication. 
bcast-TM-518.pdf
A distributed algorithm that implements a sequentially consistent collection of shared read/update objects using a combination of broadcast and point-to-point communication is presented and proved correct. This algorithm is a generalization of one used in the Orca shared object system. The algorithm caches objects in the local memory of processors according to application needs; each read operation accesses a single copy of the object, while each update accesses all copies. Copies of all the objects are kept consistent using a strategy based on sequence
numbers for broadcasts.
The algorithm is presented in two layers. The lower layer uses the given broadcast and point-to-point communication services, plus sequence numbers, to provide a new communication service called a context multicast channel. The higher layer uses a context multicast channel to manage the object replication in a consistent fashion. Both layers and their combination are described and verified formally, using the I/O automaton model for asynchronous concurrent systems.

https://www.cilkplus.org/piper-experimental-language-support-pipeline-parallelism-intel-cilk-plus
https://lists.cs.princeton.edu/pipermail/parsec-users/2011-August/001176.html
From my point of view, x264 should be more precisely be classified as a wavefront algorithm instead of a pipeline one. We have recently implemented a TBB-based template to easily code H.264. This work is briefly described in http://www.ac.uma.es/~compilacion/publicaciones/UMA-DAC-11-01.pdf (a shorter and corrected version of this technical report has been accepted in the HiPC11 conf.).

Thanks,

Rafa.
